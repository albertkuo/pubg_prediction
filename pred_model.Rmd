---
title: "PUBG Prediction Model"
author: "Albert Kuo, Athena Chen"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
---

```{r include = F}
knitr::opts_chunk$set(include = TRUE, comment = NA, warning = FALSE, 
                      message = FALSE, cache = FALSE, fig.align = 'center')
```

```{r packages, include = F, cache = F}
library(pacman) # for loading packages
p_load(tidyverse, janitor, caret, lubridate, RColorBrewer, corrplot, factoextra)
```

# Overview

<figure>
  <img src="https://media.giphy.com/media/xT0xeHi1rHNKi8j4Ck/giphy.gif" alt="sniper.gif" width="400"/>
  <img src="./assets/pubg_map.jpg" alt="pubg_map.jpg" width="223"/>
  <figcaption><i>Left: A skilled sniper taking out a moving target. Right: A PUBG map.</i></figcaption>
</figure>

## Motivation

Battle royale games have surged in popularity in recent years. The premise of such games is as follows: players are dropped onto a fictional island and fight to be the last person standing. As they roam around the island, they loot for weapons and items crucial for their survival. Players can choose to join a game as a solo player or with a group of friends (4 players maximum). When playing solo, players are immediately eliminated when they are killed. However, in group play, killed individuals can be revived by their teammates. 

We are interested in building a prediction model for the popular battle royale game PUBG (PlayerUnknown's Battlegrounds). In PUBG, players not only have to worry about getting killed by other players, but they also have to stay within the shrinking "safe zone," which effectively forces players into contact with each other. Outside of the "safe zone," players take damage to their health at increasing rates. 

Through our analysis, we aim to understand what characterizes winning players or teams: How aggressive are the playing styles of the winners? Is it better to land in a densely or sparsely populated area? Do players who travel farther on the map tend to place higher or lower? Answers to such questions will be of high interest for the PUBG gaming community.

## Related Work

This project was inspired by a [Kaggle competition](https://www.kaggle.com/c/pubg-finish-placement-prediction):

> The team at PUBG has made official game data available for the public to explore and scavenge outside of "The Blue Circle." This competition is not an official or affiliated PUBG site - Kaggle collected data made possible through the PUBG Developer API. You are given over 65,000 games' worth of anonymized player data, split into training and testing sets, and asked to predict final placement from final in-game stats and initial player ratings.

We thought that it would serve as a good final project idea for this class, since there's a lot of potential in what we could do with the data. We wanted to build upon the Kaggle competition to develop a hopefully interesting analysis.

## Initial Questions

The main goal of this project is to predict a player's finish placement based on their in-game actions. Specifically, the three subquestions of interest are:

1. **Model Prediction Accuracy**: How well can we predict a player's finish placement?
2. **Feature Ranking**: What player actions or statistics are most predictive of their finish placement?
3. **Clustering**: Which playing styles are most successful?

# Data

The data comes from the Kaggle competition.

* **For TA use**: Run the code chunk below to download the data from the Dropbox link. This link is guaranteed to be available only during the grading period. 
* **For everyone else**: Join the Kaggle competition and run the shell script `download_data.sh`.

```{r download_data}
data.url <- paste0("https://www.dropbox.com/s/mp89gp57cz2dsc7/train_V2.csv.zip?dl=1")

if(!file.exists("./data/train_V2.csv.zip")){
  download.file(data.url, destfile = "./data/train_V2.csv.zip", mode = "wb")
}
```

```{r import_data}
# Warning: Large dataset (628 MB), will take a minute or so to read.
raw_dat <- read_csv("./data/train_V2.csv.zip")

clean_dat = raw_dat %>%
  clean_names() %>%
  drop_na(win_place_perc) # Drop rows without outcome variable
```


## Variables

Each row in the data contains one player's post-game stats. A description of all data fields is provided in `data/pubg_codebook.csv`. We will focus on the solo game mode (`match_type` is solo, solo-fpp, or normal-solo-fpp). The solo game mode constitutes about 16% of the data, with 720,386 observations. The outcome variable we are trying to predict is `win_place_perc`. 

```{r clean_data}
solo_dat <- clean_dat %>% 
  #sample_n(10000) %>%
  filter(match_type %in% c("solo", "solo-fpp", "normal-solo-fpp")) %>%
  select(-dbn_os, -assists, -revives, -group_id, -match_type, -team_kills) %>%        # Remove features that are not relevant to solo mode
  mutate(kill_points = ifelse(rank_points == -1 & kill_points == 0, NA, kill_points), # Following codebook explanations
         win_points = ifelse(rank_points == -1 & win_points == 0, NA, win_points), 
         rank_points = ifelse(rank_points == -1, NA, rank_points),
         id = as.factor(id), 
         match_id = as.factor(match_id)) %>%
  select(-rank_points)    # Variable is being deprecated
```

## Training and Test Set 

We are given a training set and a test set. The outcome variable for the test set will not be provided until the end of the Kaggle competition in Jan. 30th, 2019. Therefore, for the purposes of this project, we will only be using the provided training set. Within the provided training set, we will create our own "training" (80%) and "test" set (20%). For the rest of the document, the training set we refer to is the one we've created.

```{r train_test_split}
# Split into train and test set
set.seed(1)
train_ind = createDataPartition(y = solo_dat$win_place_perc, p = 0.8, list = F)
train_solo = solo_dat %>%
  slice(train_ind)
test_solo = solo_dat %>%
  slice(-train_ind)
```

# Exploratory Data Analysis

In the training set, we have `r n_distinct(train_solo$id)` players and `r n_distinct(train_solo$match_id)` matches. 

```{r prop_data}
# Compute proportions
prop_data = train_solo %>% 
  group_by(match_id, max_place, match_duration) %>% 
  count() %>%
  ungroup() %>%
  mutate(prop = n/max_place,
         remove_game = prop > 1)

# Games with proportion greater than 100%
prop_over_100 = prop_data %>%
  summarize(prop_n = sum(prop > 1),
            prop_games = prop_n/n())

# Histogram
prop_data %>%
  ggplot(aes(x = prop)) + 
  geom_histogram(bins = 30, color = 'white') +
  labs(title = "Proportion of players we have data for in a game",
       x = "Proportion",
       y = "Count") +
  theme_minimal()

# Remove games with proportion greater than 100%
remove_match_ids = prop_data %>%
  filter(remove_game) %>%
  pull(match_id)

train_solo = train_solo %>%
  filter(!(match_id %in% remove_match_ids))
```

For most games, we have between 70% to 90% of the players' data, using `max_place` (the worst placement for which we have data) as a proxy for total number of players. For `r prop_over_100$prop_n` games (`r round(prop_over_100$prop_games*100, 2)`% of all games), we have more observations than `max_place`, which is not possible. Thus, we excluded these games from our analysis.

## Distribution of Features by Finish Percentile

We first explored the distribution of each feature by the final finish percentile. Players were first grouped into the 0-19th, 20th-39th, 40th-59th, 60th-79th, or 80th-100th percentile finish. Then we plotted the density of features by percentile groups. Note that due to extreme outliers, we excluded the highest 1% of many of the features for clearer visualizations.

```{r plot_dist_of_features_by_percentile, fig.width = 10, fig.height = 12}
set.seed(1)
filter_vars = c("boosts", "damage_dealt", "headshot_kills", "heals", "kills", "longest_kill", "ride_distance", "swim_distance", "walk_distance", "weapons_acquired")
train_solo %>% 
  filter_at(vars(filter_vars), all_vars(. < quantile(., 0.99, na.rm = T))) %>%   # Remove outliers
  rename_at(vars(filter_vars), ~ sapply(filter_vars, function(str) paste0(str, "*"))) %>% # Mark variables for which we removed outliers with asterisk features
  mutate(win_place_cat = floor(win_place_perc / 0.2),
         win_place_cat = ifelse(win_place_cat == 5, 4, win_place_cat),
         win_place_cat = as.factor(win_place_cat)) %>%
  gather("feature", "value", -match_id, -match_duration, 
         -id, -win_place_perc, -win_place_cat) %>%
  ggplot(aes(x = value, group = win_place_cat, color = win_place_cat)) +
  facet_wrap(feature ~., scales = "free") +
  geom_density() +
  labs(title = "Distribution of Features by Finish Percentile", 
       caption = "* Removed outliers (> 99th percentile) from this feature's density plot",
       x = "Value of Features", y = "Density", color = "Percentile") +
  scale_color_manual(labels = c("0-19", "20-39", "40-59", "60-79", "80-100"),
                     values = brewer.pal(5, "OrRd")) +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```
  
**Note: Need to resolve warning (non-finite values)**

Some interesting relationships between the features and the finish percentile:

- **Use of Items** (`boosts`, `heals`, and `weapons_acquired`): Players who finish higher tend to have used more boosts and healing items, and acquired more weapons. This is expected since they stayed in the game for a longer period and have more time to collect and use items. However, it would be interesting to explore which of these variables is most predictive of a high finish placement.

- **Kills & Damage** (`damage_dealt`, `kill_place`, and `kills`): Players who finish higher tend to have more kills. They also tend to have dealt more damage. However, in the top finishing group, there is a wide variety in how much damage they inflict. This could potentially indicate strategies that differ in their level of aggressiveness during the course of the game but are similarly successful in achieving a high placement. 

- **Distance Traveled** (`walk_distance`, `swim_distance`, and `ride_distance`): Players who finish higher tend to have walked farther. This is likely because they simply survive longer and are force to travel to stay in the safe zone, whereas players who die early don't get a chance to travel very far. Both swimming and riding in vehicles are rare occurrences, though it appears that players who finish higher also tend to do more of both.

(Additional notes to ourselves regarding some features of the data we might want to look at):

* `kill_place`, `kill_points`, `kills`, and `win_points` follow bimodal distributions. This may reflect the play-styles of each player. Players who land in populated areas are more likely to encounter other players, resulting in a higher porbability of dying or a larger number of kills if the player survives. Thus, we can partition players in the 10th percentile finish into two categories: a skilled player who but dies early due to dropping in a populated location, but due to their skill acquires a large number of kills or a less-skilled player who dies early due to lack of skill despite dropping in a less populated location. 
* Some features look highly skewed (e.g. `longest_kill`, `ride_distance`, `swim_distance`, `ride_distance`, etc.). We may want to log-transform these variables in our model building. 
* The `num_groups` density plots suggest that in games where we have little data, we tend to have data on the winners. Thus, there may be some imbalance in the data we will need to either adjust for to ensure that our model doesn't overestimate finish percentile. 
* `rank_points`, `win_points` and `kill_points` are external characteristics (from previous games) that attempt to characterize the skill level of a player. These distributions are bimodal which may reflect the extremes of the two playstyles described above. It seems that `kill_points` has more predictive value of finish percentile as the right-shift is more distinct by finish percentage category than `rank_points`. Interestingly, `rank_points` suggests that prior-game ranks do not have a large impact on the final placement in a game (though there is a note int the `pubg_codebook.csv` file that this metric is deprecated). This makes sense since in-game variables like drop location, loot, and circle movement can affect how likely an individual is to win. 

## Correlation Plot

Statistics related to `kills` seem to be well correlated with finish percentile. Additional duration of game does not seem to be strongly correlated with many of the in-game features such as `kills`, `walk_distance`, etc. 

```{r corr_plot, fig.width = 10, fig.height = 12}
corr_matrix = train_solo %>% 
  select(-id, -match_id) %>% 
  cor()

corrplot(corr_matrix, method = "color", type = "upper")
```

# Data Analysis

## Predictive Models

We will fit the following models:

1. Linear regression
2. Elastic net regression
3. Random forest
4. Any others in the caret package?

### Linear Regression

First, we fit a linear regression model with 5-fold cross-validation. Since the final win percentage must be a value beteen 0 and 1, we log-transform `1 + win_place_perc` where the `1` is added to ensure all values are defined. The initial model will include all features except for the match ID and player ID, since neither feature is going to generalize for predicting new games, which is what we are interested in. 

```{r lm}
set.seed(1)
tc = trainControl(method = "cv", number = 5)

# Fit linear model using step-wise model selection using AIC
lr_model = train(log(win_place_perc + 1) ~ . - match_id - id, data = train_solo, 
                 method = "lmStepAIC", trControl = tc, trace = FALSE)
summary(lr_model)

# Look at relative importance of individual predictors in the model
varImp(lr_model$finalModel) %>% 
  mutate(variable = rownames(.)) %>%
  arrange(desc(Overall))

# Look at plot of predicted values versus true values on training set
train_solo %>% 
  mutate(predicted = exp(lr_model$finalModel$fitted.values)-1) %>%
  ggplot(aes(x = predicted, y = win_place_perc)) +
  geom_point() +
  labs(title = "Predicted Versus Actual Win Place Percentage in the Training Set", 
       x = "Predicted Win Place Percentage", y = "Actual Win Place Percentage") +
  geom_abline(intercept = 0, slope = 1, color = 'red') +
  theme_bw()
```

### Elastic net regression

As we noted earlier in the data exploration, some of the features are highly correlated and/or seem to provide little signal (such as distance traveled). To solve these issues, we implement elastic net regression which uses a ridge-regression-like penalty to adjust for correlated features and lasso penalty to set the non-informative features to zero. 

```{r lasso}
# Fit lasso_model using glmnet
lasso_model = train(log(win_place_perc +1) ~ . - match_id - id, data = train_solo, 
                    method = "glmnet", trControl = tc)
print(lasso_model)

# Look at coefficients of final model
coef(lasso_model$finalModel, lasso_model$bestTune$lambda)

# Look at relative importance of predictors in the model
varImp(lasso_model$finalModel) %>% mutate(variable = rownames(.)) %>%
  arrange(desc(Overall))

# Look at plot of predicted values versus true values on training set
lasso_fitted = predict(lasso_model, train_solo)
train_solo %>% 
  mutate(predicted = exp(lasso_fitted)-1) %>%
  ggplot(aes(x = predicted, y = win_place_perc)) +
  geom_point() +
  labs(title = "Predicted Versus Actual Win Place Percentage in the Training Set", 
       x = "Predicted Win Place Percentage", y = "Actual Win Place Percentage") +
  geom_abline(intercept = 0, slope = 1, color = 'red') +
  theme_bw()
```

### Random Forest

To account for correlation between features, another option is to use a random forest classifier. We train a random forest model below. 

```{r rf, eval = F}
rf_model = train(log(win_place_perc + 1) ~ . - match_id - id, data = train_solo, 
                 method = "rf", trControl = tc)
print(rf_model)
```

### Comparison of Models with Cross-Validated MSE

Here we can provide a table (or plot) of MSEs (or some metric representing accuracy, caret probably has a default) for each model. Then we say X model has the highest accuracy.

### Evaluating Model Performance on the Test Set

As we have found that X model has the highest accuracy in the training set, we validate our results on an independent test set. 

```{r lr_test}
# Linear regression
lr_pred = predict(lr_model, newdata = test_solo)

# Get MSE
lr_MSE = mean((exp(lr_pred) - 1 - test_solo$win_place_perc)^2)
```

On the test set, the model performance is X.

### Summary of Models

To summarize, we use a couple of different models to predict the win place percentage. With X as our metric, we found that performed best using 5-fold cross validation on the training set. On an independent test set, the accuracy was X. 

## Clustering and Features

We can try the following and see which one gives us a better story:

1. We can do PCA, plot observations along principal components, color points by outcome, and then try to interpret the top principal components in terms of the features.

2. Manually summarize the features into something like the 3-4 categories described in the exploratory data analysis section, i.e. engineer a summary feature for "damage/kills", another summary feature for "distance travelled." Consult correlation plot and PCA plot to get good groupings as well. Then plot observations along these summary features and color points by outcome. This is basically the same idea as PCA except we already have a story in place for what the components mean.

### Principal Components Analysis

```{r pca}
# PCA
X = train_solo %>%
  select(-win_place_perc, -id, -match_id) %>%
  as.matrix()

pc = prcomp(X, center = T, scale = T)

# Plot eigenvalues (percentage of variances explained by each principal component)
fviz_eig(pc)

# Plot cumulative variance explained by the first k PCs
data.frame(cumvar = cumsum(pc$sdev^2/sum(pc$sdev^2))) %>%
  ggplot(aes(x = 1:length(cumvar), y = cumvar*100)) +
  geom_point() +
  geom_line() + 
  labs(title = "Cumulative Variance Explained by the First K PCs", 
       x = "K", y = "Percent of Variance Explained") +
  theme_bw()

# Plot variables in terms of the first two principal components
# Positively correlated variables point in the same direction, negative correlated variables point to opposite direction
fviz_pca_var(pc,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```

The first principal component explains much of the variance we see in our features (29.6%), while the second to sixth principal component all explain between 5 to 10%. In the second plot, we can observe each feature's contribution to the first two principal components and their correlations.

1. **PC 1**: It appears that the first principal component comprises of features related to damage and kills, primarily the features `kills`, `kill_place`, `damage_dealt`. To a lesser extent, features like `damage_dealt`, `longest_kill`, `headshot_kills`, `boosts`, and `heals` also exhibit contribution primarily to the first principal component. 

2. **PC 2**: The second principal component is characterized by details related to the match setting, i.e. `num_groups` and `max_place`, as well as `win_points` and `kill_points`, which I don't remember what they mean.

Remaining features like `road_kills`, `vehicle_destroys`, `ride_distance` do not contribute much to either of the first two principal components. We should investigate if they do to the third principal component.

```{r pca_points}
# Plot points on principal components 1 and 2 
data.frame(PC1 = pc$x[,1], PC2 = pc$x[,2]) %>%
  ggplot(aes(PC1, PC2, color = train_solo$win_place_perc)) +
  geom_point(aes(alpha = 0.5)) +
  labs(title = "Win Place Percent of Training Data by PC1 and PC2",
       color = "Win Place Percent") +
  guides(alpha = F) +
  theme_bw()

# Plot point on principal components 1 and 3
data.frame(PC1 = pc$x[,1], PC3 = pc$x[,3]) %>%
  ggplot(aes(PC1, PC3, color = train_solo$win_place_perc)) +
  geom_point(aes(alpha = 0.5)) +
  labs(title = "Win Place Percent of Training Data by PC1 and PC3",
       color = "Win Place Percent") +
  guides(alpha = F) +
  theme_bw()

# Plot point on principal components 2 and 3
data.frame(PC2 = pc$x[,2], PC3 = pc$x[,3]) %>%
  ggplot(aes(PC2, PC3, color = train_solo$win_place_perc)) +
  geom_point(aes(alpha = 0.5)) +
  labs(title = "Win Place Percent of Training Data by PC2 and PC3",
       color = "Win Place Percent") +
  guides(alpha = F) +
  theme_bw()
```

Our outcome variable `win_place_perc` is pretty well explained by the first princiapl component. There are also interesting clusters formed when we plot principal components 2 and 3 that we should investigate.

Principal components regression. How does it compare to our earlier models?

## Questions:
1. Do we want to engineer features and refit the data? Kill/damage, match characteristics, use of items, distance traveled?
2. K-means clustering with k = 2? (One for 2 play styles: aggressive, hiding)
3. What PC space do we want? looks like 4-5 captures a decent amount of variance?

## Feature Ranking

Which features are most predictive? The features that contribute to PC1 are likely to be predictive. Plot variable importance from models as well. 

# Narrative and Summary
